'use strict';

function t(t,r,e){return void 0===(t=(r.split?r.split("."):r).reduce(function(t,r){return t&&t[r]},t))?e:t}function r(t,r,e,n){return (r=r.split?r.split("."):r.slice(0)).slice(0,-1).reduce(function(t,r){return /^(__proto__|constructor|prototype)$/.test(r)?{}:t[r]=t[r]||{}},t)[r.pop()]=e,t}

function defaultTo(a, b) {
  return a != null ? a : b;
}
function getOption(fallback, key, options1, options2) {
  return defaultTo(defaultTo(options1[key], options2[key]), fallback);
}
function createPersistedStatePlugin(options) {
  var pluginOptions = options || {};
  function plugin(context) {
    // normalize
    var options = function () {
      try {
        return context.options.persistedState || {};
      } catch (_a) {
        return {};
      }
    }();
    if (getOption(true, 'persist', options, pluginOptions) === false) return;
    var key = getOption(context.store.$id, 'key', options, {});
    var overwrite = getOption(false, 'overwrite', options, pluginOptions);
    var storage = getOption(function () {
      try {
        return window.localStorage;
      } catch (_a) {
        return {
          getItem: function getItem() {},
          setItem: function setItem() {},
          removeItem: function removeItem() {}
        };
      }
    }(), 'storage', options, pluginOptions);
    var filter = getOption(function () {
      return true;
    }, 'filter', options, pluginOptions);
    var serialize = getOption(JSON.stringify, 'serialize', options, pluginOptions);
    var deserialize = getOption(JSON.parse, 'deserialize', options, pluginOptions);
    var migrate = getOption(function (_) {
      return _;
    }, 'migrate', options, {});
    var merge = getOption(function (state, savedState) {
      return savedState;
    }, 'merge', options, {});
    var assertStorage = getOption(function (storage) {
      var uniqueKey = '@@';
      var result = storage.setItem(uniqueKey, '1');
      var removeItem = function removeItem() {
        storage.removeItem(uniqueKey);
      };
      if (result instanceof Promise) {
        result.then(removeItem);
      } else {
        removeItem();
      }
    }, 'assertStorage', options, pluginOptions);
    function patchOrOverwrite(state) {
      (options.beforeHydrate || function () {})(context.store.$state);
      var merged = merge(context.store.$state, state);
      if (overwrite) {
        context.store.$state = merged;
      } else {
        context.store.$patch(merged);
      }
      resolveIsReady();
    }
    function parse(value) {
      if (value != null) {
        var state = deserialize(value);
        var migrateState = migrate(state);
        if (migrateState instanceof Promise) {
          migrateState.then(patchOrOverwrite);
        } else {
          patchOrOverwrite(migrateState);
        }
      } else {
        resolveIsReady();
      }
    }
    // initialize custom properties
    var resolveIsReady;
    var isReadyPromise = new Promise(function (resolve) {
      resolveIsReady = resolve;
    });
    var pendingCount = 0;
    context.store.$persistedState = {
      isReady: function isReady() {
        return isReadyPromise;
      },
      pending: false
    };
    // hydrate
    try {
      if ('development' !== 'production') {
        var assertStorageValue = assertStorage(storage);
        if (assertStorageValue instanceof Promise) {
          assertStorageValue.then(function () {
            return hydrate();
          })["catch"](function (error) {
            return console.warn(error);
          });
        } else {
          hydrate();
        }
      }
    } catch (error) {
      console.warn(error);
      resolveIsReady();
    }
    function hydrate() {
      var value = storage.getItem(key);
      if (value instanceof Promise) {
        value.then(parse);
      } else {
        parse(value);
      }
    }
    // persist
    var callback = function callback(mutation, state) {
      if (filter(mutation, state) === false) return;
      if (Array.isArray(options.includePaths)) {
        state = options.includePaths.reduce(function (partialState, path) {
          return r(partialState, path, t(state, path, void 0));
        }, {});
      }
      if (Array.isArray(options.excludePaths)) {
        state = deserialize(serialize(state));
        options.excludePaths.forEach(function (path) {
          return r(state, path, void 0);
        }, {});
      }
      var value = serialize(state);
      var result = storage.setItem(key, value);
      if (result instanceof Promise) {
        ++pendingCount;
        context.store.$persistedState.pending = pendingCount !== 0;
        result["catch"](function () {})["finally"](function () {
          --pendingCount;
          context.store.$persistedState.pending = pendingCount !== 0;
        });
      }
    };
    context.store.$subscribe(callback);
  }
  return plugin;
}

exports.createPersistedStatePlugin = createPersistedStatePlugin;
